{
  "title": "2.2 The Binomial Tree Model",
  "source_type": "pdf",
  "duration_estimate_sec": 2100,
  "chapters": [
    {
      "name": "From one-step to a full binomial tree: the market set-up",
      "narration": "We’re going to build the binomial tree model in a way that makes pricing feel inevitable, not magical.\n\nStart with the motivation: a one-step up-or-down model is too small to describe how prices evolve over time. If we want to price derivatives with maturities that span multiple periods, we need a multi-step structure. That structure is a tree.\n\nIn this model there are two traded instruments.\nFirst, a risky stock, which we’ll call S.\nSecond, a risk-free cash or discount bond, which we’ll call B.\n\nThe market assumptions are the usual frictionless idealization: you can trade as much as you want, whenever you want, there are no transaction costs, no bid–ask spreads, and no default in the bond.\n\nTime is discrete. We move in equal time increments—each increment is one tick, or one period, of length delta t.\n\nAt tick-time i, the stock can be in multiple states. As we add a new time step, every existing state branches into two possible next states: an up state and a down state. That repeated branching is what creates the tree.\n\nIn the next chapter we’ll make that branching precise, and we’ll describe how the bond evolves alongside the stock.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "\\text{Number of stock states at tick }i:\\quad 2^{i}",
          "spoken": "The number of possible stock states at tick-time i is two to the power i.",
          "intuition": "Each time step, every node splits into two children. Doubling each step gives 1, 2, 4, 8, and so on—so after i steps there are two to the i possible nodes."
        }
      ],
      "figure_narration": []
    },
    {
      "name": "How the stock and bond evolve on the tree",
      "narration": "Let’s now describe the mechanics of the tree.\n\nPick any node in the tree. At that node, the stock price takes some value—call it s sub j, meaning the stock price at node j. From that node, in the next tick, exactly two things can happen.\n\nOne branch is the up move, occurring with probability p sub j.\nThe other branch is the down move, occurring with probability one minus p sub j.\n\nA key point: these p sub j’s are the real-world, or physical, probabilities. They help you describe how the stock might move in reality, but they are not yet the probabilities we will use for pricing.\n\nNow for the bond. The bond is our risk-free benchmark. In the most realistic discrete-time formulation, the short rate can change from one period to the next. So you have a sequence of known short rates: R zero, R one, and so on.\n\nIf rates vary, the bond accumulates by compounding across periods: each period contributes its rate times the period length to the exponent.\n\nFor simplicity, we often assume a constant continuously-compounded rate r. Then the bond grows by the same factor every period.\n\nThis matters because discounting is how we translate future cash flows back to a current value. In the next chapter we’ll use that discounting idea together with no-arbitrage to derive the pricing recursion.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "s_j \\xrightarrow{p_j} s_{2j+1},\\qquad s_j \\xrightarrow{1-p_j} s_{2j}",
          "spoken": "From node j, with stock price s sub j, the stock moves up to s sub two j plus one with probability p sub j, and it moves down to s sub two j with probability one minus p sub j.",
          "intuition": "Each node has exactly two successors. The labels two j and two j plus one are just a bookkeeping system to uniquely name the down-child and the up-child."
        },
        {
          "latex": "B\\bigl(n\\Delta t\\bigr) = B_0\\exp\\Bigl(\\sum_{i=0}^{n-1} R_i\\,\\Delta t\\Bigr)",
          "spoken": "The bond value at time n times delta t equals B zero times the exponential of the sum, from i equals zero to n minus one, of R sub i times delta t.",
          "intuition": "With continuous compounding, each period contributes a log-growth of R sub i times delta t, so adding them in the exponent compounds them across time."
        },
        {
          "latex": "B\\bigl(n\\Delta t\\bigr) = B_0\\exp\\bigl(r\\,n\\Delta t\\bigr)\\quad\\text{(constant rate }r\\text{)}",
          "spoken": "If the interest rate is constant at r, then the bond value at time n times delta t is B zero times e to the power r times n times delta t.",
          "intuition": "Constant continuous compounding gives exponential growth at a steady rate r, so discounting over n periods is just multiplying by e to the minus r n delta t."
        }
      ],
      "figure_narration": [
        {
          "figure_id": "Figure 2.3",
          "description": "A binary tree diagram. Time runs left to right in discrete steps: tick i on the left and tick i plus one on the right. A single node at time i is labeled s_j. From that node, two branches extend to the right. The upper branch goes to a child node labeled s_{2j+1} and is annotated with probability p_j. The lower branch goes to a child node labeled s_{2j} and is annotated with probability 1 minus p_j. The overall drawing suggests that as you move right across multiple ticks, the number of nodes grows by repeated splitting.",
          "chart_type": "binary tree diagram",
          "axes": "Implicit horizontal axis: discrete time ticks i, i+1, i+2, ...; implicit vertical axis: different node positions representing different stock price states (no numeric scale).",
          "trend": "Each node splits into two successor nodes each period, so the count of possible states doubles at each tick.",
          "significance": "This picture is the structural backbone for pricing by backward induction: values are computed locally on each fork and then propagated backward through the tree."
        }
      ]
    },
    {
      "name": "Backward induction: price from the boundary condition",
      "narration": "Now we come to the principle that turns a tree into a pricing machine: backward induction.\n\nA derivative has a payoff at expiration. That payoff is known once the stock price at maturity is known. So at the final time layer of the tree, we can write down the derivative value node-by-node. That terminal layer is our boundary condition.\n\nFrom there, we work backward one time step at a time.\n\nAt any node before maturity, what information do you have? You know the entire stock history that led you to this node—formally, the filtration. But because the tree is built so that each node represents the current state, the derivative’s value at that node is a single number. It cannot depend on which path you “remember” if those paths lead to the same node in a recombining tree.\n\nThe finiteness of the tree is not just mathematical convenience: most real claims expire. So a finite terminal layer is realistic and gives us a clear stopping point.\n\nIn the next chapter we’ll derive the one-step pricing formula that makes the backward step explicit: the value at a node becomes a discounted expectation of the two successor values—but crucially under a modified probability.\n\n[Pause 5 seconds]",
      "spoken_math": [],
      "figure_narration": []
    },
    {
      "name": "Local no-arbitrage pricing: the one-step recursion and the risk-neutral probability",
      "narration": "Let’s derive the local pricing step.\n\nTake one node j. In the next period there are two possible successor nodes, with two possible derivative values: one in the up state and one in the down state.\n\nThe key no-arbitrage idea is replication. You form a portfolio of stock and bond today at node j so that, one period later, the portfolio value matches the derivative value in both successor states. If you can do that, the derivative must have the same value today as the cost of that replicating portfolio—otherwise you could lock in an arbitrage.\n\nWhen you write the replication equations and solve, something remarkable happens: the derivative value at the node can be written as a discounted weighted average of the two successor derivative values.\n\nBut the weights are not the physical probabilities p sub j. They are adjusted weights—call them q sub j—chosen precisely to enforce the no-arbitrage relationship between today’s stock price and the discounted expected stock price next period.\n\nSo, locally, we get a pricing recursion: value now equals discounted expectation of value next step, under q sub j.\n\nIn the next chapter, we’ll see how repeating this one-step rule produces multi-step pricing, including a clean expression for time-zero value as a discounted expected payoff over all paths.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "f(j) = e^{-r\\,\\delta t}\\left(q_j\\,f(2j+1) + (1-q_j)\\,f(2j)\\right)",
          "spoken": "The derivative value at node j equals e to the minus r delta t times the quantity: q sub j times the derivative value at the up child node, plus one minus q sub j times the derivative value at the down child node.",
          "intuition": "This is the local risk-neutral valuation step. Discount at the risk-free rate, then take an expectation under the special probability q that is consistent with no-arbitrage."
        },
        {
          "latex": "q_j = \\frac{s_j\\exp(r\\,\\delta t) - s_{2j}}{s_{2j+1} - s_{2j}}",
          "spoken": "q sub j equals the numerator s sub j times e to the r delta t minus s sub two j, divided by s sub two j plus one minus s sub two j.",
          "intuition": "q is picked so that, under q, the expected next stock price—then discounted back at the risk-free rate—matches today’s stock price. That makes the discounted stock behave like a martingale under the pricing measure."
        }
      ],
      "figure_narration": [
        {
          "figure_id": "Figure 2.4",
          "description": "A small two-step tree. At time 0 there is a single root node labeled 1. From it, two branches go to time 1: an upper node labeled 3 and a lower node labeled 2. From node 3 at time 1, two branches go to time 2 terminal nodes labeled 7 (upper) and 6 (lower). From node 2 at time 1, two branches go to time 2 terminal nodes labeled 5 (upper) and 4 (lower). The branches out of the root are annotated with a local up probability q1. The branches out of node 2 and node 3 are annotated with local probabilities q2 and q3, showing that different nodes can have different risk-neutral probabilities.",
          "chart_type": "binary tree / double-fork diagram",
          "axes": "Implicit horizontal axis: discrete time 0, 1, 2; implicit vertical axis: node positions representing different states (no numeric scale).",
          "trend": "The diagram highlights that pricing is performed fork-by-fork: each node has its own q, and values are computed by moving from time 2 back to time 0.",
          "significance": "It makes the recursion concrete: you can literally point to a node, look at its two children, apply discounting and q-weighting, and get the node value."
        }
      ]
    },
    {
      "name": "Two-step expansion: path probabilities are products of branch q’s",
      "narration": "Once you accept the one-step recursion, multi-step valuation is just repeated substitution.\n\nIn a two-step tree, you first compute values at time 1 from the terminal payoffs at time 2. Then you compute the time 0 value from the two time 1 values.\n\nAlgebraically, when you substitute the time 1 expressions into the time 0 expression, you end up with a single discounted sum of the four terminal payoffs.\n\nEach terminal payoff is multiplied by a weight. That weight is the probability of the entire path under the risk-neutral measure, and it is built by multiplying the branch probabilities along the path.\n\nSo “up then up” has weight q1 times q3.\n“Up then down” has weight q1 times one minus q3.\n“Down then up” has weight one minus q1 times q2.\n“Down then down” has weight one minus q1 times one minus q2.\n\nThis is the bridge from local pricing to global pricing: local q’s determine path weights; path weights produce a global expected discounted payoff.\n\nNext we’ll formalize this with backward induction as an inductive argument, and then we’ll do a full numerical example.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "f(1)=e^{-2r\\,\\delta t}\\big[ q_1 q_3 f_7 + q_1(1-q_3) f_6 + (1-q_1) q_2 f_5 + (1-q_1)(1-q_2) f_4 \\big]",
          "spoken": "The derivative value at the root node 1 equals e to the minus two r delta t times: q one q three times terminal value f seven, plus q one times one minus q three times f six, plus one minus q one times q two times f five, plus one minus q one times one minus q two times f four.",
          "intuition": "Two-step valuation is just discounted expectation over terminal nodes, and each terminal node’s weight is the product of the branch probabilities on the way there."
        },
        {
          "latex": "P(\\text{up,up})=q_1 q_3,\\quad P(\\text{up,down})=q_1(1-q_3),\\quad P(\\text{down,up})=(1-q_1)q_2,\\quad P(\\text{down,down})=(1-q_1)(1-q_2)",
          "spoken": "The risk-neutral path probability of up then up is q one times q three. Up then down is q one times one minus q three. Down then up is one minus q one times q two. Down then down is one minus q one times one minus q two.",
          "intuition": "Path probabilities multiply because a path is a sequence of branch choices; in the tree model the probability of the sequence is the product of the step-by-step probabilities."
        }
      ],
      "figure_narration": [
        {
          "figure_id": "small tree illustrations (pages 8)",
          "description": "A set of small sub-tree sketches focusing on one parent node and its two children. One example highlights node 3 as the parent at time 1, with two arrows to nodes 7 and 6 at time 2. The arrows are labeled with q3 for the up branch and 1 minus q3 for the down branch. Similar snippets appear for other parent nodes, emphasizing that the same one-step formula is applied repeatedly at different locations in the tree.",
          "chart_type": "schematic sub-tree snippets",
          "axes": "Implicit horizontal axis: parent time to child time; vertical axis: up child above down child.",
          "trend": "No continuous trend; the visual emphasis is on repeating the same local averaging rule across different nodes.",
          "significance": "These snippets help prevent index confusion: they show exactly which two values are being averaged at each backward step."
        }
      ]
    },
    {
      "name": "Induction and replication: existence and uniqueness of node prices",
      "narration": "Let’s step back and ask: why does this procedure give a unique price?\n\nThe logic is inductive.\n\nAt maturity, the derivative payoff is known. That’s the base case.\n\nNow assume you already know the arbitrage-free derivative values at all nodes at time i plus one. Consider any node at time i. It has exactly two children at time i plus one, and therefore two continuation values for the derivative. You can solve for a portfolio of stock and bond that matches those two continuation values after one period.\n\nIf such a replicating portfolio exists, then the derivative value at the parent node must equal the portfolio cost, or else there would be an arbitrage.\n\nSo one step backward gives you a unique enforced value at that node.\n\nRepeating this step backward through all time layers produces a unique time-zero price.\n\nAnd the replication is not just local bookkeeping. If you rebalance the portfolio at each node according to the node-specific holdings—phi for stock and psi for bond—then along any realized path, the portfolio matches the derivative’s payoff at maturity. That’s the global replication strategy.\n\nNext, we’ll make all of this tangible with a concrete recombining three-period example: we’ll compute a European call price and the dynamic hedge ratios node by node.\n\n[Pause 5 seconds]",
      "spoken_math": [],
      "figure_narration": [
        {
          "figure_id": "Figure 2.5",
          "description": "A recombining stock-price tree drawn over three periods. The horizontal direction shows time 0, time 1, time 2, time 3. At time 0 there is one node at stock price 100. At time 1 there are two nodes: 120 above and 80 below. At time 2 the tree recombines into three nodes: 140 at the top, 100 in the middle, and 60 at the bottom. At time 3 there are more terminal stock prices shown, arranged vertically from high to low; the key point is that the tree is recombining so that mixed up-then-down paths meet at the same intermediate node (for example, the middle node 100 at time 2). Branches are labeled with physical probabilities: up probability 3/4 and down probability 1/4. The slide notes an interest rate of zero and poses a European call with strike 100 expiring at time 3.",
          "chart_type": "recombining binomial tree diagram",
          "axes": "Horizontal axis: discrete time steps 0, 1, 2, 3 (periods). Vertical axis: stock price level in dollars at nodes (discrete values like 60, 80, 100, 120, 140, 160).",
          "trend": "Stock prices move up or down each period; recombination causes different paths to meet at the same intermediate prices, reducing the number of distinct nodes compared to a non-recombining tree.",
          "significance": "This is the computational advantage of recombination and the practical stage for backward induction: fewer nodes means fewer pricing calculations, while still capturing multi-step uncertainty."
        }
      ]
    },
    {
      "name": "Worked example: pricing a European call by backward induction",
      "narration": "Now let’s price the call option in the example tree.\n\nWe are pricing a European call with strike 100 at time 3. The interest rate is taken to be zero, so we don’t need to apply discount factors numerically—although conceptually discounting is always there.\n\nStep 1: write terminal payoffs at time 3. For each terminal stock price, the call payoff is the positive part of stock minus 100. So if the terminal stock is below 100, payoff is zero; if above 100, payoff is stock minus 100.\n\nStep 2: compute the risk-neutral probability q at each node. In this particular worked example, q turns out to be one half everywhere.\n\nStep 3: work backward.\nAt each node, the option value is q times the up-child value plus one minus q times the down-child value. With q equal to one half, that becomes a simple average of the two child values.\n\nCarrying that backward induction through the tree produces intermediate values at time 2, then time 1, and finally the time-zero price.\n\nThe final result in this example is an option price of 15 at time 0.\n\nIn the next chapter we’ll connect this price to hedging: we’ll compute the stock holding phi that replicates the option locally at each node, and we’ll see how the required hedge changes as the stock moves.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "q = \\dfrac{s_{now} - s_{down}}{s_{up} - s_{down}}",
          "spoken": "q equals s now minus s down, divided by s up minus s down.",
          "intuition": "In a one-step binomial model with zero interest, q is the weight that makes the current stock equal the expected next stock under q. It is determined by no-arbitrage, not by historical frequencies."
        },
        {
          "latex": "f_{now} = q\\,f_{up} + (1-q)\\,f_{down}",
          "spoken": "The claim value now equals q times the up value plus one minus q times the down value.",
          "intuition": "Once q is fixed by no-arbitrage, the derivative price becomes the risk-neutral expected next value; with zero interest this is just a weighted average."
        },
        {
          "latex": "F(1_{up}) = \\frac{40+10}{2} = 25,\\quad F(1_{down})=\\frac{10+0}{2}=5,\\quad F(0)=\\frac{25+5}{2}=15",
          "spoken": "At time 1 after an up move, the option value is the average of 40 and 10, giving 25. At time 1 after a down move, the value is the average of 10 and 0, giving 5. And at time 0, the value is the average of 25 and 5, giving 15.",
          "intuition": "Backward induction repeatedly averages child-node values when q is one half, pushing terminal payoffs back through the tree to today’s price."
        }
      ],
      "figure_narration": [
        {
          "figure_id": "Figure 2.6 / 2.7",
          "description": "Two aligned trees. The first shows terminal option payoffs at time 3 written at the terminal nodes: zeros at low stock prices and positive payoffs at higher stock prices, including values like 20 and 60 at the relevant in-the-money terminals. The second tree shows the computed option values at earlier times placed on the corresponding nodes: at time 2 values 40, 10, and 0; at time 1 values 25 and 5; and at time 0 the value 15. The layout mirrors the stock tree so you can visually trace how each earlier node value is obtained from its two children.",
          "chart_type": "value tree (option payoff and backward-induced option value)",
          "axes": "Horizontal axis: time levels 0 to 3. Vertical axis: option value in dollars at nodes (discrete).",
          "trend": "Values generally increase as you move to higher stock-price branches; earlier-time values are smoother because each is an average of two later values.",
          "significance": "This is backward induction made visual: it shows that the option’s current value is determined entirely by terminal payoffs and the risk-neutral averaging rule."
        }
      ]
    },
    {
      "name": "Hedging and self-financing replication: phi and psi along paths",
      "narration": "Pricing tells you what the option is worth. Hedging tells you how to manufacture that payoff.\n\nAt each node, the replicating portfolio holds phi shares of stock plus psi units of the bond.\n\nPhi is chosen so that the portfolio’s difference between the up outcome and the down outcome matches the option’s difference between the up and down option values. That eliminates exposure to which branch happens over the next step.\n\nNumerically in the example, phi changes over time and across nodes.\nAt time 0, phi is 0.5.\nAfter an up move, phi increases to 0.75.\nLater, deeper in-the-money, phi becomes 1.\nAlong a different path, phi can decrease instead—because the option becomes less sensitive when it is out-of-the-money.\n\nTo keep the strategy self-financing, when phi changes you must borrow or lend via the bond position. The bookkeeping is: increasing phi means you buy extra stock at the current price, which increases borrowing; decreasing phi means you sell stock and can repay borrowing.\n\nThe tables in the slides track this along two sample paths: one where the option finishes in-the-money, and another where it finishes out-of-the-money. In both cases, the final portfolio value matches the option payoff—this is replication in action.\n\nNext we’ll connect this replication view to risk-neutral expectations, and we’ll see explicitly why the risk-neutral measure is not the same as the real-world probability measure.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "\\varphi = \\dfrac{f_{up} - f_{down}}{s_{up} - s_{down}}",
          "spoken": "Phi equals f up minus f down, divided by s up minus s down.",
          "intuition": "This is a finite-difference slope: how much the option value changes relative to how much the stock changes between the two next states. Holding that many shares matches the option’s sensitivity over the next step."
        },
        {
          "latex": "\\varphi_{t=0} = \\dfrac{25-5}{120-80} = 0.5,\\quad \\varphi_{t=1,\\,up}=\\dfrac{40-10}{140-100}=0.75,\\quad \\varphi_{t=2,\\,uu}=\\dfrac{60-20}{160-120}=1",
          "spoken": "At time zero, phi is 25 minus 5 over 120 minus 80, which is 0.5. At time one after an up move, phi is 40 minus 10 over 140 minus 100, which is 0.75. At time two after two up moves, phi is 60 minus 20 over 160 minus 120, which is 1.",
          "intuition": "As the option moves further in-the-money, its payoff behaves more and more like the stock itself, so the replicating strategy needs more shares per option."
        }
      ],
      "figure_narration": [
        {
          "figure_id": "Table 2.1",
          "description": "A table with rows for times 0, 1, 2, and 3 along a mostly-up path. Columns include: Time; the last jump direction; the stock price S in dollars; the option value V in dollars; the hedge ratio phi; and the bond position psi, shown as negative numbers indicating borrowing. The entries show phi rising from 0.5 to 0.75 to 1.0, while psi becomes more negative, reaching about minus 100 by time 2 and staying there through time 3 in the illustrated path.",
          "chart_type": "table (path-wise replication ledger)",
          "axes": "Not a plot; columns provide units: stock price and option value in dollars; phi in shares per option; psi in bond units or dollars of borrowing (negative indicates borrowing).",
          "trend": "Along the up moves, phi increases and borrowing grows in magnitude to finance the larger stock position.",
          "significance": "Shows the strategy is self-financing and path-consistent: the evolving stock holding and bond borrowing replicate the option value node by node."
        },
        {
          "figure_id": "Table 2.2",
          "description": "A second table with rows for times 0, 1, 2, and 3 along an alternate path that includes a down move early. The same columns appear: Time, last jump, stock price, option value, phi, and psi. Here phi drops from 0.5 at time 0 to 0.25 after the down move, then rises to 0.5 after an up move. The bond position psi adjusts accordingly, becoming less negative after reducing stock, then more negative again when increasing stock.",
          "chart_type": "table (path-wise replication ledger)",
          "axes": "Not a plot; columns provide units: dollars for stock and option values; shares per option for phi; borrowing or lending in the bond for psi.",
          "trend": "When the stock falls and the option becomes less responsive, phi decreases and borrowing is partially repaid; later adjustments reverse this.",
          "significance": "Demonstrates that replication is not a single static hedge: the hedge ratio depends on the node, and correct rebalancing ensures the final portfolio matches the option payoff even when the option expires worthless."
        }
      ]
    },
    {
      "name": "Risk-neutral valuation: why Q-pricing differs from real-world expectation",
      "narration": "We can now tie the story together.\n\nThere are two probability concepts in the slides.\n\nFirst is the physical measure—call it P—with real-world up probability p. In the example, p is three quarters.\n\nSecond is the risk-neutral measure—call it Q—built from the arbitrage probabilities q, which in the example are one half.\n\nThe crucial statement is: arbitrage-free pricing uses Q, not P.\n\nIf you compute the expected payoff using p equals three quarters, you may get a number like 33.75. But that is not the fair price, because it ignores that investors can trade dynamically in stock and bond to eliminate risk. The fair price is the one consistent with replication and no-arbitrage, and that price is the discounted expectation under Q.\n\nIn the example with zero interest, the Q expectation gives 15, matching the backward induction result and matching the cost of the replicating strategy.\n\nSo, in the binomial model, pricing is not about forecasting. It is about enforcing no-arbitrage through replication, and that enforcement produces the risk-neutral probabilities.\n\nNext we’ll finish with a compact checklist of the core formulas: q, phi, psi, the one-step pricing recursion, and the global valuation as a discounted Q-expectation.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "V_0=E_{Q}[\\text{discounted payoff}]\\\\\\text{(in example, }V_0=(1/8)\\cdot 60+(3/8)\\cdot 20=15\\text{)}",
          "spoken": "The time-zero value equals the Q-expectation of the discounted payoff. In the example with zero interest, the value is one eighth times 60 plus three eighths times 20, which equals 15.",
          "intuition": "Under Q, you weight payoffs by risk-neutral path probabilities. Only the in-the-money terminal nodes contribute, and the weighted average matches the replication cost."
        },
        {
          "latex": "P\\text{-probabilities example: }(3/4)^3=27/64,\\quad 3\\times(3/4)^2(1/4)=27/64,\\quad 3\\times(3/4)(1/4)^2=9/64,\\quad(1/4)^3=1/64",
          "spoken": "Under the physical probability with up chance three quarters, the probability of three ups is 27 over 64. The probability of exactly two ups is three times three quarters squared times one quarter, also 27 over 64. Exactly one up is three times three quarters times one quarter squared, which is 9 over 64. And zero ups is one quarter cubed, which is 1 over 64.",
          "intuition": "Real-world likelihoods can heavily favor up moves, but pricing ignores those likelihoods unless they coincide with risk-neutral probabilities. No-arbitrage prices come from hedging, not from the physical drift."
        }
      ],
      "figure_narration": []
    },
    {
      "name": "Compact summary: the binomial-tree pricing toolkit",
      "narration": "Let’s close by summarizing the toolkit.\n\nOne: specify the claim and write its terminal payoff at maturity.\n\nTwo: use backward induction. At each node, price equals discounted expectation of next-step values under the arbitrage probability q.\n\nThree: compute q from stock prices and the risk-free rate so that discounted expected stock equals today’s stock.\n\nFour: compute the hedge ratio phi as the option-value difference divided by the stock-price difference across the up and down states.\n\nFive: compute the bond position psi to make the portfolio value match the option value at the node.\n\nFinally: when you link all local steps together, the time-zero price equals the discounted expectation of the terminal payoff under the risk-neutral measure Q formed by multiplying the local q’s along paths.\n\nThat is the binomial tree model in one sentence: local replication implies local risk-neutral pricing, and repeated local pricing implies global discounted Q-expectation.\n\n[Pause 5 seconds]",
      "spoken_math": [
        {
          "latex": "\\psi = B^{-1}_{\\text{now}}\\left(f_{\\text{now}} - \\phi\\,s_{\\text{now}}\\right)",
          "spoken": "Psi equals one over B now times the quantity f now minus phi times s now.",
          "intuition": "After choosing phi shares to match the option’s sensitivity, psi is whatever bond position is needed to match the option’s total value at the node."
        },
        {
          "latex": "V = \\mathbb{E}_Q\\left[B_T^{-1}\\,X\\right]",
          "spoken": "The time-zero value V equals the Q-expectation of B at maturity to the minus one times X, where X is the payoff at maturity.",
          "intuition": "Discount the payoff by the bond numeraire and average under the risk-neutral measure. This global formula is just the multi-step version of the one-step recursion."
        }
      ],
      "figure_narration": [
        {
          "figure_id": "Summary_Table_Page_20",
          "description": "A compact summary table with rows listing the core quantities and formulas: the arbitrage up probability q; the stock holding phi; the one-step local pricing rule for f now as a weighted average of f up and f down; the bond holding psi computed from f now minus phi times s now scaled by the bond value; and the global valuation formula expressing today’s price as the Q-expectation of the discounted payoff. A small glossary alongside the table lists the symbol meanings: s for stock, f for claim value, r for interest rate, delta t for step size, Q for the pricing measure, and X for the terminal payoff.",
          "chart_type": "summary table",
          "axes": "Not applicable; this is a formula reference table rather than a plot. Units implied: prices and payoffs in dollars; phi in shares; discounting via the bond.",
          "trend": "No trend; it is a consolidation of relationships.",
          "significance": "Serves as the checklist for implementing binomial pricing: given stock nodes and a bond process, you can compute q, then price by backward induction, and hedge via phi and psi."
        }
      ]
    }
  ],
  "final_recap": "We modeled the stock in discrete time as a binomial tree, alongside a risk-free bond that accumulates at the short rate. Starting from the terminal payoff as a boundary condition, we priced derivatives by backward induction: at each node, the derivative value is the discounted expectation of its two successor values under a node-specific risk-neutral probability q. The q’s are determined by no-arbitrage, not by the physical probabilities p. The same no-arbitrage logic yields a replicating portfolio at each node with hedge ratio phi and bond position psi, and chaining these local hedges replicates the payoff along every path. Globally, this produces the central result: today’s price equals the discounted Q-expectation of the terminal payoff."
}